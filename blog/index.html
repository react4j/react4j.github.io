<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Blog · React4j</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Blog · React4j"/><meta property="og:type" content="website"/><meta property="og:url" content="https://react4j.github.io/index.html"/><meta property="og:description" content="An opinionated java react binding"/><link rel="shortcut icon" href="/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/idea.min.css"/><link rel="alternate" type="application/atom+xml" href="https://react4j.github.io/blog/atom.xml" title="React4j Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://react4j.github.io/blog/feed.xml" title="React4j Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/css/main.css"/></head><body><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logo.svg"/><h2 class="headerTitle">React4j</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/overview.html" target="_self">Docs</a></li><li><a href="/api" target="_self">API</a></li><li><a href="/blog" target="_self">Blog</a></li><li><a href="https://github.com/react4j/react4j/releases" target="_blank">Releases</a></li><li><a href="https://github.com/react4j/react4j" target="_blank">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Recent Posts</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Recent Posts</h3><ul><li class="navListItem"><a class="navItem" href="/blog/2019/01/30/version-0.115-release.html">React4j 0.115 released</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/01/30/version-0.114-release.html">React4j 0.114 released</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/01/21/version-0.113-release.html">React4j 0.113 released</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/01/18/version-0.112-release.html">React4j 0.112 released</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/01/17/version-0.111-release.html">React4j 0.111 released</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer documentContainer postContainer blogContainer"><div class="wrapper"><div class="posts"><div class="post"><header class="postHeader"><h1><a href="/blog/2019/01/30/version-0.115-release.html">React4j 0.115 released</a></h1><p class="post-meta">January 30, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/react4j" target="_blank">React4j Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/react4j/react4j/compare/v0.114...v0.115">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[core]</strong> Improve the javadocs on the <code>ReactComponent.Type</code> enums to clarify when a component will be
re-rendered.</li>
<li><strong>[processor]</strong> Generate an error if a <code>@Prop</code> has specified <code>immutable=true</code> and either
<code>shouldUpdateOnChange=ENABLE</code> or <code>observable=ENABLE</code>.</li>
<li><strong>[processor]</strong> If a <code>@Prop</code> has specified <code>immutable=true</code> and <code>shouldUpdateOnChange=AUTODETECT</code> then
resolve the <code>shouldUpdateOnChange</code> parameter to <code>DISABLE</code>.</li>
<li><strong>[processor]</strong> Implement the <code>shouldComponentUpdate()</code> lifecycle method for all components, even if
they have no props or no props where <code>shouldUpdateOnChange</code> resolves to <code>ENABLE</code>. This is so that components
have consistent behaviour regardless of whether they require a prop or not. This is more consistent
behaviour but is a breaking change compared to version <code>0.114</code> that would re-render components with no
props every time their container was re-rendered.</li>
<li><strong>[processor]</strong> Add missing type parameters in generated component class to avoid <code>unchecked</code> compiler warning.</li>
<li><strong>[dom]</strong> Add explicit cast in generated <code>DOM</code> factory to avoid varargs compiler warning.</li>
<li><strong>[processor]</strong> Add support for defining react components with constructors that take parameters. These
parameters are injected into the component similarly to <code>@Inject</code> annotated fields.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2019/01/30/version-0.114-release.html">React4j 0.114 released</a></h1><p class="post-meta">January 30, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/react4j" target="_blank">React4j Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/react4j/react4j/compare/v0.113...v0.114">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[core]</strong> Merge the <code>react4j-arez</code> artifact into <code>react4j-core</code> as the <code>react4j-core</code> artifact has never
been used without also using <code>react4j-arez</code> in any production application.</li>
<li><strong>[core]</strong> Move the <code>ObservableValue</code> introspection utilities from <code>ReactArezComponent</code> into the new utility
class <code>react4j.internal.arez.IntrospectUtil</code> as the code is not expected to be used by end-user code.</li>
<li><strong>[core]</strong> Move the <code>Observer</code> introspection utilities from <code>ReactArezComponent</code> into the new utility
class <code>react4j.internal.arez.IntrospectUtil</code> as the code is not expected to be used by end-user code.</li>
<li><strong>[core]</strong> Extract some utility code out of <code>ReactArezComponent</code> into a new utility
class <code>react4j.internal.arez.SchedulerUtil</code> as the code is not expected to be used by end-user code.</li>
<li><strong>[processor]</strong> Classes that extend <code>react4j.Component</code> but not <code>react4j.arez.ReactArezComponent</code> are now
generated as <code>@ArezComponent(allowEmpty=true)</code> annotated classes. This means that the normal arez lifecycle
methods (i.e. those annotated with <code>@PostConstruct</code>, <code>@PreDispose</code>, <code>@PostDispose</code> etc.) are available to all
react4j components as are helper annotations such as <code>@CascadeDispose</code>. This removes the need to implement
parallel capabilities into the react4j annotation processor and significantly simplifies integration with
the injection framework.</li>
<li><strong>[core]</strong> Move <code>ReactArezComponent.getArezComponentId()</code> to <code>Component.getComponentId()</code> and
<code>ReactArezComponent.getArezComponentName()</code> to <code>Component.getComponentName()</code> so that the methods are available
to all react components.</li>
<li><strong>[arez]</strong> Update the <code>org.realityforge.arez</code> dependencies to version <code>0.127</code>.</li>
<li><strong>[core]</strong> Guard the data emitted as debug state to ensure that all the required compile time properties are
set to <code>true</code> before emitting debug values. This includes <code>react4j.store_debug_data_as_state</code> as well as the
associated Arez compile time properties <code>arez.enable_spies</code> and/or <code>arez.enable_names</code>. This ensures that these
compile time properties can be controlled independently while ensuring unused code is optimized out.</li>
<li><strong>[processor]</strong> Fix bug where the enhanced component classes would trigger the Arez scheduler twice if there
was any schedulable elements that were part of the component. The second trigger would result in no action as
there would be no pending tasks but it did result in more code being generated than required. Removing the custom
react4j triggering resulted in reduced code size where this feature was used.</li>
<li><strong>[processor]</strong> Fix bug where the enhanced component classes with fields annotated with <code>@Dependency</code> would
trigger at the incorrect time and potentially result in null pointer exceptions.</li>
<li><strong>[processor]</strong> Allow Arez annotations on react components that do not extend <code>ReactArezComponent</code> as there
is no longer any reason to disallow that scenario.</li>
<li><strong>[core]</strong> Remove the <code>ReactArezComponent.getContext()</code> as it is no longer required within react4j. Users can
add a similar method back in, if/when it is needed.</li>
<li><strong>[core]</strong> Remove the constructor in <code>ReactArezComponent</code> as it was only overridden to make it protected
access but the class is abstract so can never be directly instantiated and thus the override had no impact.</li>
<li><strong>[processor]</strong> Generate the <code>populateDebugData(data)</code> method for components that extend the <code>ReactArezComponent</code>
class rather than inheriting implementation from <code>ReactArezComponent</code>. The purpose is to make it easier to remove
<code>ReactArezComponent</code> and use the compiler to optimize away unneeded code.</li>
<li><strong>[processor]</strong> Move the <code>ReactArezComponent.getRenderObserver()</code> method into the generated class as user code
does not need access to the raw Observer instance.</li>
<li><strong>[core]</strong> Re-add the <code>Component.scheduleRender()</code> method that takes no parameters.</li>
<li><strong>[processor]</strong> Move the remaining logic in <code>ReactArezComponent</code> to classes generated by the annotation
processor in preparation for removing <code>ReactArezComponent</code> and also enabling better optimization by the GWT
and J2CL compilers.</li>
<li>Archive the <code>react4j-widget</code> library as there is no desire or need to continue supporting it. While the library
will likely continue to work, the project will not verify this going forward.</li>
<li><strong>[processor]</strong> Remove <code>react4j.internal.NativeAdapterComponent</code> and have the annotation processor generate
the required infrastructure per-component. This affords more opportunities for the optimizing compilers to eliminate
unused code and simplifies understanding of the generated classes.</li>
<li><strong>[core]</strong> Remove the <code>dagger</code> parameter from <code>@ReactComponent</code> as the framework has not supported alternative
injection frameworks for a while and thus the parameter provided no actual value.</li>
<li><strong>[core]</strong> Completely rewrite the injection framework support is generated to use infrastructure supplied by
the Arez component model now that all react4j components are Arez components.</li>
<li><strong>[core]</strong> Convert <code>Component.bindComponent()</code> to protected access and add invariant check to verify that it is
not called multiple times.</li>
<li><strong>[core]</strong> Remove lifecycle method <code>Component.componentDidCatch(...)</code> and replace with annotation <code>@OnError</code>.</li>
<li><strong>[processor]</strong> Move from <code>Disposable.dispose( this )</code> to <code>((Arez_MyComponent) this).dispose()</code> so that the
optimizing compiler can inline the method where possible.</li>
<li><strong>[core]</strong> Change <code>ReactElement.createFragment(...)</code> and <code>React.createFragment(...)</code> methods to accept a
nullable key parameter and add add a factory method in <code>react4j.dom.DOM</code> that accepts a key. Keys are valid on
fragment nodes and the code has been change to reflect this.</li>
<li><strong>[core]</strong> Add initial support for <code>&lt;Suspense/&gt;</code> component.</li>
<li><strong>[dom]</strong> Add support for <code>ReactDOM.createRoot(...)</code> as the first step for enabling usage of concurrent mode.</li>
<li><strong>[core]</strong> Add the <code>immutable</code> parameter to the <code>@Prop</code> annotation. If set to true then the react component
will be recreated if the value of the prop changes. This is accomplished by synthesizing a key for the component
from the set of immutable props. If any prop has been marked as immutable then it will no longer possible for the
developer to manually specify the key parameter.</li>
<li><strong>[core]</strong> The error message from annotation processor when a user defines a prop named <code>key</code> suggested using
a method that does not exist and has not worked since upgraded to React 16+ so update the error message.</li>
<li><strong>[core]</strong> Remove <code>React.createFragment()</code> in favour of directly calling <code>ReactElement.createFragment()</code>.</li>
<li><strong>[core]</strong> Remove every variant of <code>React.createElement(...)</code>. The code and/or behaviour has been inlined into
the <code>DOM</code> factory methods to aid code optimization process.</li>
<li><strong>[core]</strong> Move <code>React.createStrictMode(...)</code> to <code>ReactElement.createStrictMode(...)</code>.</li>
<li><strong>[core]</strong> Remove the <code>ReactArezComponent</code> class and replace it with the <code>type</code> parameter on the
<code>@ReactComponent</code> annotation. The possible values for <code>type</code> are:
<ul>
<li><code>STATEFUL</code>: The component can use fields or lifecycle methods.</li>
<li><code>TRACKING</code>: The component is <code>STATEFUL</code> and the render method is annotated with <code>@Observe</code> and will
re-render when a dependency changes.</li>
<li><code>MAYBE_TRACKING</code>: The component is <code>TRACKING</code> but the render method may have zero dependencies.</li>
</ul></li>
<li><strong>[core]</strong> Remove the <code>allowNoArezDeps</code> parameter from the <code>@ReactComponent</code> annotation as it no longer
provides any value over <code>MAYBE_TRACKING</code> components.</li>
<li><strong>[core]</strong> Add support for <code>@Prop(disposable=ENABLE)</code> props in <code>@ReactComponent(type=STATEFUL)</code> components
and update <code>@Prop(disposable=AUTODETECT)</code> to resolve correctly detect disposable props even in <code>STATEFUL</code>
components.</li>
<li><strong>[core]</strong> Add support for <code>@Prop(observable=ENABLE)</code> props in <code>@ReactComponent(type=STATEFUL)</code> components
and update <code>@Prop(disposable=AUTODETECT)</code> to resolve correctly detect observable props even in <code>STATEFUL</code>
components. See javadocs for further details.</li>
<li><strong>[processor]</strong> Remove an &quot;optimization&quot; that resulted in the <code>shouldComponentUpdate()</code> react lifecycle being
omitted if all the props were <code>observable=DISABLE</code> and <code>shouldUpdateOnChange=ENABLE</code>.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2019/01/21/version-0.113-release.html">React4j 0.113 released</a></h1><p class="post-meta">January 21, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/react4j" target="_blank">React4j Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/react4j/react4j/compare/v0.112...v0.113">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[core]</strong> Add the parameter <code>allowNoArezDeps</code> to the <code>ReactComponent</code> component to support scenario
where an Arez/React4j component may render without any arez dependencies. This may be acceptable.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2019/01/18/version-0.112-release.html">React4j 0.112 released</a></h1><p class="post-meta">January 18, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/react4j" target="_blank">React4j Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/react4j/react4j/compare/v0.111...v0.112">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[processor]</strong> Extract the definition of the lifecycle methods from out of each of the generated
component subclasses into interfaces such as <code>react4j.OnComponentDidMount</code>, <code>react4j.OnComponentDidUpdate</code>
etc. The native implementations then implement each lifecycle interface as required rather than synthesizing
a aggregate lifecycle definition custom to that component.</li>
<li><strong>[core]</strong> Simplify the <code>Component.storeDebugDataAsState()</code> to make it easier to identify when the debug
state is updated.</li>
<li><strong>[core]</strong> Move internal classes used by the code generator to the <code>react4j.internal</code> package so that it
is clear that they are not intended to be referenced by external code and may change between releases. The
classes move include the classes named <code>react4j.On*</code>, <code>react4j.Native*</code> and <code>react4j.ComponentConstructorFunction</code>.</li>
<li><strong>[core]</strong> Move the method used used to access compile time configuration from the <code>ReactConfig</code> class to the
<code>React</code> class and change the access level of <code>ReactConfig</code> to package access.</li>
<li><strong>[processor]</strong> Remove the <code>prevProps</code> parameter from the synthetic <code>componentDidUpdate()</code> lifecycle method
on the java component if it is unused.</li>
<li><strong>[processor]</strong> Improve the code generated for the synthetic <code>shouldComponentUpdate()</code> lifecycle method on
the java component by eliminating unused local variables if unused.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2019/01/17/version-0.111-release.html">React4j 0.111 released</a></h1><p class="post-meta">January 17, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/react4j" target="_blank">React4j Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/react4j/react4j/compare/v0.110...v0.111">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[processor]</strong> Ensure that the synthesized lifecycle methods are private unless they are annotated by the
<code>@arez.annotations.Action</code> annotation. Prior to this change different methods had different policies, some
were optionally private, some were final and some were package access.</li>
<li><strong>[core]</strong> Fix bug introduced into <code>React.createFragment(...)</code> in <code>0.109</code> as a result of setting the
<code>$typeof</code> key to <code>React.Fragment</code> rather than <code>React.Element</code>.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2019/01/16/version-0.110-release.html">React4j 0.110 released</a></h1><p class="post-meta">January 16, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/react4j" target="_blank">React4j Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/react4j/react4j/compare/v0.109...v0.110">Full Changelog</a></p>
<p>Changes in this release:</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2019/01/16/version-0.109-release.html">React4j 0.109 released</a></h1><p class="post-meta">January 16, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/react4j" target="_blank">React4j Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/react4j/react4j/compare/v0.108...v0.109">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[core]</strong> Rename the <code>@OnPropChanged</code> annotation to <code>@OnPropChange</code>.</li>
<li><strong>[core]</strong> Add support for the <code>Component.componentPreUpdate(...)</code> lifecycle method that is invoked prior
to updating a.k.a. re-rendering a component. This is mapped to the native <code>getSnapshotBeforeUpdate</code>
lifecycle method except that the application developer can not return a value from the method.</li>
<li><strong>[processor]</strong> Change the way observable props are generated so that the change detection for the props
occurs in the <code>shouldComponentUpdate(...)</code> and <code>componentPreUpdate(...)</code> lifecycle steps rather than the
<code>shouldComponentUpdate(...)</code> and <code>componentDidUpdate(...)</code> lifecycle steps. This means that the <code>@Memoize</code>
annotated methods that have a return value derived from observable props will be marked as possibly stale
before a call to <code>render()</code> occurs and the component will not need to be re-rendered to reflect a changed
value returned from the <code>@Memoized</code> method.</li>
<li><strong>[core]</strong> Change the <code>@OnPropChange</code> annotation so that it accepts one or more parameters. Each parameter
represents a prop that is tracked for changes. Any time a change occurs in any prop then the annotated method
is invoked. The parameters are mapped to props based on a naming pattern or via an explicit <code>@PropRef</code>
annotation if the naming convention is insufficient.</li>
<li><strong>[core]</strong> Change the <code>@OnPropChange</code> annotation so that it accepts a <code>phase</code> parameter that controls
whether the method is invoked before the component is updated/rendered or after the component is updated.</li>
<li><strong>[core]</strong> Introduce the <code>@PreUpdate</code> annotation that can be used to annotate a method that is invoked
when a component is about to be updated or re-rendered.</li>
<li><strong>[core]</strong> Introduce the <code>@PostUpdate</code> annotation that can be used to annotated a method that is invoked
when a component has been updated or re-rendered. This replaces the ability to override the
<code>componentDidUpdate()</code> lifecycle method.</li>
<li><strong>[core]</strong> Introduce the <code>@PostMount</code> annotation that can be used to annotated a method that is invoked
after a component has been mounted. This replaces the ability to override the <code>componentDidMount()</code> lifecycle method.</li>
<li><strong>[core]</strong> Reduce the access level of <code>Component.start()</code> method so that it is package access and
no longer accessible by subclasses. It has not been modifiable since version <code>0.102</code> of React4j and there is
no reason to read it when writing components.</li>
<li><strong>[arez]</strong> Fix invariant failure that occurred when generating debug state for a component that extends
<code>ReactArezComponent</code> that has observed an Arez observable that has no accessor defined.</li>
<li><strong>[core]</strong> Remove invariant checking based on the state of the react component. This invariant checking
was duplicating functionality already implemented by the underlying <code>ReactJS</code> library. This also involved
removing the compile time setting <code>react4j.check_component_state_invariants</code> and the accessor
<code>ReactConfig.checkComponentStateInvariants()</code>.</li>
<li><strong>[arez]</strong> Update the <code>org.realityforge.arez</code> dependencies to version <code>0.122</code>.</li>
<li><strong>[processor]</strong> Optimize the processor so that <code>shouldComponentUpdate(...)</code> methods are not generated on
<code>Lite</code> native components if the component has <code>@PropValidate</code> annotated props but has no observable props
and is not an Arez component. This reduces the code size and eliminates a noop lifecycle method.</li>
<li><strong>[processor]</strong> Optimize the processor so that the <code>componentDidUpdate(...)</code> and <code>componentDidMount(...)</code>
methods are not generated on a non-arez component unless those features are required to implement other
capabilities. This reduces code size and eliminates unnecessary work for React during rendering.</li>
<li><strong>[arez]</strong> Update the <code>ReactArezComponent</code> class to change the strategy via which resources are released
to use the <code>@PreDispose</code> annotation from Arez to mark the component as unmounted. This avoids the overhead
associated with pausing and resuming the scheduler and reduces code size by using builtin Arez mechanisms.</li>
<li><strong>[core]</strong> Introduce the <code>@PostRender</code> annotation that can be used to annotated a method that is invoked
when a component has been rendered. This can be after the component has been mounted or after it has been
updated. This method is invoked before the <code>@PostUpdate</code> annotated method in the <code>componentDidUpdate(...)</code>
method and before the <code>@PostMount</code> annotated method in the <code>componentDidMount(...)</code> method.</li>
<li><strong>[core]</strong> Re-introduce the boolean parameter <code>force</code> to <code>Component.scheduleRender()</code> method so that it
is possible to trigger a re-render but still pass through the <code>shouldComponentUpdate()</code> lifecycle stage if
present.</li>
<li><strong>[processor]</strong> Avoid generating <code>componentPreUpdate</code> lifecycle method for components that have have
observable props and no <code>@PreUpdate</code> or <code>@OnPropChange(phase=PRE)</code> annotated methods. This was achieved by
migrating all observable prop monitoring into <code>shouldComponentUpdate</code> and out of the <code>componentPreUpdate</code>
lifecycle method.</li>
<li><strong>[processor]</strong> Avoid generating the <code>shouldComponentUpdate</code> lifecycle method if changes to any prop will
cause the component to be re-rendered and there are no observable methods for component.</li>
<li><strong>[core]</strong> Remove the <code>ReactArezEnvironment</code> class as it no longer provides any value given that the Arez
scheduler is paused until a subsequent microtask.</li>
<li><strong>[core]</strong> Introduce the <code>@PreUnmount</code> annotation that can be used to annotate a method that is invoked
before a component is unmounted or detatched. This replaces the ability to override the
<code>componentWillUnmount()</code> lifecycle method.</li>
<li><strong>[core]</strong> Remove the <code>React.cloneElement(...)</code> method as it has never been used by any React4j application
and if it was used it could be reimplemented in java rather than relying on javascript extern.</li>
<li><strong>[dom]</strong> Remove the invariant check in <code>ReactDOM.render(...)</code> that duplicates check already present in
native react.js code.</li>
<li><strong>[core]</strong> Remove the unused <code>React.isReactElement(...)</code> method.</li>
<li><strong>[core]</strong> Import Closure Compiler annotated externs for react. This is needed to support the closure
compiler compilation stage that is part of J2CL compilation.</li>
<li><strong>[core]</strong> Remove the <code>Component.getKey()</code> as it is not expected to work as keys are not stored on props.</li>
<li><strong>[core]</strong> Mark the <code>Component.props</code> and the <code>Component.state</code> externs as <code>@nosideeffects</code> so closure
compiler will remove accesses if results are unused.</li>
<li><strong>[core]</strong> Use the builtin mechanisms for defining Arez component ids. The React4j previously shared a
single generator across every component while the new version has a per-type generator. Thew builtin variant
produces slightly more optimized code.</li>
<li><strong>[processor]</strong> Ensure that components that extend <code>ReactArezComponent</code> never implement <code>DisposeTrackable</code>
as this feature does not make sense for a react component.</li>
<li><strong>[processor]</strong> Remove <code>isDisposed( this )</code> check inside <code>render()</code> method for components that extend
<code>ReactArezComponent</code> as there should be no scenario where the component is disposed without going through
<code>componentWillUnmount()</code> lifecycle stage. Eliminating this check reduces the size of code.</li>
<li><strong>[arez]</strong> Refactor the <code>react4j.arez.Arez</code> module to remove the inherit from <code>react4j.dom.Dom</code> as it is
no longer used.</li>
<li><strong>[processor]</strong> Change the name of the interfaces used to construct the components from <code>BuilderN</code> to
<code>StepN</code> to improve clarity as the <code>&quot;Builder&quot;</code> nomenclature is over-used in that class.</li>
<li><strong>[core]</strong> Ensure that component elements have their key initialized to <code>null</code> rather than leaving it
<code>undefined</code>. This results in monomorphic code when processing these type of elements and eliminates a
source of deoptimization that can occur in V8. This also eliminates a correctness bug that can occur in
fragments that contain a list of keyed and unkeyed elements which resulted in incorrect behaviour during
reconciliation.</li>
<li><strong>[core]</strong> Change the <code>$$typeof</code> property on fragments from <code>Symbol(react.element)</code> to <code>Symbol(react.fragment)</code>.
The change seems to have no behavioural difference as the reconciler uses <code>type</code> field to control behaviour
but it makes it easier for humans visually inspecting data.</li>
<li><strong>[core]</strong> Remove addition of empty string to <code>key</code> element when supplied as a prop and instead just
cast the key to a string. The supporting infrastructure no longer supplies non-string keys and adding an
empty string will stop the GWT compiler from removing <code>toString()</code> on any subclass of <code>Object</code> (i.e. no
<code>toString()</code> methods are candidates for dead code elimination).</li>
<li><strong>[processor]</strong> Eliminate the static inner class named <code>Prop</code> from the enhanced react component if it is empty.</li>
<li><strong>[processor]</strong> Rename the generated dagger helper class from <code>[MyComponent]DaggerFactory</code> to
<code>[MyComponent]DaggerComponentExtension</code> to align with the same pattern in Arez.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2018/11/22/version-0.108-release.html">React4j 0.108 released</a></h1><p class="post-meta">November 22, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/react4j" target="_blank">React4j Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/react4j/react4j/compare/v0.107...v0.108">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[processor]</strong> The generated builder previously supported a <code>child(ReactNode)</code> method on components that
supported multiple children. The <code>child(ReactNode)</code> supported accumulation of children over multiple
invocations. This feature was not used in any downstream project and made certain optimizations difficult.
This method is no longer generated. A method with the same function in <code>Context.Provider</code> class was also
removed for the same reason.</li>
<li><strong>[core]</strong> Remove <code>react4j.Key</code> as the values is always converted to a string so convert at API layer.</li>
<li><strong>[processor]</strong> Refactor the annotation processor to directly create <code>ReactElement</code> instances. This
reduces some memory overhead by:
<ul>
<li>eliminating the need to handle <code>key</code> as a prop for components.</li>
<li>eliminating the duplication of the props object.</li>
<li>inlining the setting of default props into component builder. This eliminated the need to set the static
property <code>defaultProps</code> onto the component constructor function.</li>
</ul></li>
<li><strong>[core]</strong> Remove the <code>React.createElement(...)</code> methods used for creating component <code>ReactElement</code>
instances as they are no longer used anymore.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2018/11/19/version-0.107-release.html">React4j 0.107 released</a></h1><p class="post-meta">November 19, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/react4j" target="_blank">React4j Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/react4j/react4j/compare/v0.106...v0.107">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[arez]</strong> Update the <code>org.realityforge.arez</code> dependencies to version <code>0.115</code>.</li>
<li><strong>[processor]</strong> Simplify the way that the provider is generated for dagger injection enabled components.
This goal was to eliminate a level of indirection that was previously required due to the type parameters on the
<code>react4j.Component</code> class. The indirection is still required if the component class is not public but can be
eliminated when the component class is public and thus guaranteed to be accessible from the associated
<code>DaggerComponent</code>.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2018/11/08/version-0.106-release.html">React4j 0.106 released</a></h1><p class="post-meta">November 8, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/react4j" target="_blank">React4j Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/react4j/react4j/compare/v0.105...v0.106">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[processor]</strong> Upgrade the version of javapoet to <code>1.11.1</code>.</li>
<li><strong>[processor]</strong> Upgrade the Dagger2 support to version <code>2.19</code>.</li>
<li><strong>[dom]</strong> Remove the methods from the <code>DOM</code> factory class that accepted <code>JsArray</code> parameters. These
methods have never been used in downstream projects.</li>
<li><strong>[core]</strong> Rewrite the javascript <code>React.createElement(...)</code> method in java. This allows the GWT2.x/J2CL
compilers to alias methods and optimize the code. This will will result in smaller code sizes as the number
of calls to that method increases but may increase the size of the code in smaller code bases.</li>
<li><strong>[processor]</strong> Fix a bug in introduced when the annotation processor that started to optimize prop names
that resulted in the keys of the <code>defaultProps</code> value being <code>undefined</code> and thus no default prop values being
supplied.</li>
<li><strong>[arez]</strong> Update the <code>org.realityforge.arez</code> dependencies to version <code>0.114</code>.</li>
<li><strong>[processor]</strong> Move the constant holding the <code>ComponentConstructorFunction</code> instance field to a separate
inner class to avoid having to check <code>&lt;clinit&gt;</code> has been invoked prior to accessing methods on synthetic
subclass. This results in a modest decrease in size per react component.</li>
<li><strong>[processor]</strong> Move the constant holding the <code>PROP_myKey</code> static constants to a separate class to avoid
the creation of a <code>&lt;clinit&gt;</code> when not needed. Rename the constant to remove the <code>PROP_</code> prefix now that it is
no longer needed.</li>
<li><strong>[processor]</strong> Move the injection support into static inner class within generated component to avoid
the creation of a <code>&lt;clinit&gt;</code> when not needed. This results in small decrease in code size.</li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next" href="/blog/page2/">Next →</a></div></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/logo.svg" alt="React4j" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/overview.html">Overview</a><a href="/api/index.html">API Reference</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" href="https://github.com/react4j/react4j" data-icon="octicon-star" data-count-href="/react4j/react4j/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2019 the React4j Project.</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: 'bcbf32ec3754c54aadb410fd32ca236b',
                indexName: 'react4j',
                inputSelector: '#search_input_react'
              });
            </script></body></html>