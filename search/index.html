<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="generator" content="Jekyll v3.3.0">

		<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700">
		<link rel="stylesheet" href="/css/main.css">

		<title>Search</title>

		<link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
		<link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
		<link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
		<link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
		<link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
		<link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
		<link rel="icon" type="image/png" sizes="192x192"  href="/android-icon-192x192.png">
		<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#ffffff">
		<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
		<meta name="theme-color" content="#ffffff">
	</head>

	<body>
		<header>
			<h1>
				<img src="/images/logo.svg" alt="React4j" width="45">
				React4J User Manual
				<button type="button" class="open-nav" id="open-nav"></button>
			</h1>

			<form action="/search/" method="get">
				<input type="text" name="q" id="search-input" placeholder="Search" autofocus>
				<input type="submit" value="Search" style="display: none;">
			</form>

			<nav >
				<ul>
					<li class="nav-item top-level ">
						
						<a href="/">Introduction</a>
					</li>
				</ul>

				<ul>
					
					
						<li class="nav-item top-level ">
							
							<a href="/faq/">General</a>
							<ul>
								
									<li class="nav-item "><a href="/faq/">Frequently Asked Questions</a></li>
								
									<li class="nav-item "><a href="/compared_to_react/">Compared to React</a></li>
								
									<li class="nav-item "><a href="/arez/">Arez</a></li>
								
									<li class="nav-item "><a href="/dependency_injection/">Dependency Injection</a></li>
								
							</ul>
						</li>
					
				</ul>
				<ul>
					<li class="nav-item top-level">
						
						<a href="/api/index.html" target="_blank">Javadocs</a>
					</li>
				</ul>
				<ul>
					<li class="nav-item top-level ">
						
						<a href="/changelog/">Change Log</a>
					</li>
				</ul>
			</nav>
		</header>

		<section class="main">
			<div class="page-header">
				<h2>React4J User Manual</h2>
				<h3>Search</h3>
			</div>
			<article class="content">
				<p><span id="search-process">Loading</span> results <span id="search-query-container" style="display: none;">for "<strong id="search-query"></strong>"</span></p>
<ul id="search-results"></ul>

<script>
	window.data = {
		
			
				
					
					

					"arez": {
						"id": "arez",
						"title": "Arez",
						"category": "",
						"url": " /arez/",
						"content": "The combination of Arez and React4j creates a powerful toolkit. Arez manages the application state and React4j transforms the application state into a view. The React4jArez library provides the mechanisms for synchronizing the application state with the view. Both React4j and Arez are based on functional principles and trade higher memory usage for faster execution speed. React reduces the number of expensive DOM updates through the use of a virtual DOM. The application builds a future view and this is reconciled against the current view and any differences are applied to the DOM. Arez is built around a data flow graph where state modifications flow through the graph updating nodes only as required. Data nodes are always up to date and perform the minimum amount of work based on the graph definition. The React4jArez library bridges the two systems, triggering view updates when the state updates. Changes to observable data that a ReactArezComponent component uses during rendering will schedule the component for re-rendering. The developer controls the scope of the re-render by controlling the size of the component. Getting Started The simplest approach to defining an Arez enabled component is simply to extend ReactArezComponent. This will result in the render() method being invoked within the scope of a read-only, tracking (Arez) transaction. Changes to the observable state accessed within the scope of the render() will schedule the component for re-rendering. As most event handlers within a ReactArezComponent component will either access or mutate observable state, the helper methods generated as a result of annotating a method with @EventHandler will default to being annotated with arez’s @Action annotation. If you do not wish an event handler to be run as an action you can annotate the event handler with the @NoAutoAction annotation. This can be useful if you want to explicitly control the actions parameters (i.e. to make the action run in a read-only transaction) or you want to optimize a frequently called event handler by removing the overhead associated with annotating a method with @Action. Below is a Footer component extracted from a TodoMVC implementation. It accesses the observable state AppData.model.totalCount(), AppData.viewService.getFilterMode() and AppData.model.completedCount() and will re-render each time any of these values change. @ReactComponent class Footer extends ReactArezComponent&lt;BaseProps, BaseContext&gt; { @EventHandler( MouseEventHandler.class ) void handleClearCompleted() { AppData.service.clearCompleted(); } @Nullable @Override protected ReactNode render() { final int count = AppData.model.totalCount(); final String activeTodoWord = \"item\" + ( count == 1 ? \"\" : \"s\" ); final FilterMode filterMode = AppData.viewService.getFilterMode(); return footer( new HtmlProps().className( \"footer\" ), span( new HtmlProps().className( \"todo-count\" ), strong( Integer.toString( count ) ), text( \" \" + activeTodoWord + \" left\" ) ), ul( new HtmlProps().className( \"filters\" ), li( a( new AnchorProps() .className( FilterMode.ALL == filterMode ? \"selected\" : \"\" ) .href( \"#\" ), \"All\" ) ), li( a( new AnchorProps() .className( FilterMode.ACTIVE == filterMode ? \"selected\" : \"\" ) .href( \"#active\" ), \"Active\" ) ), li( a( new AnchorProps() .className( FilterMode.COMPLETED == filterMode ? \"selected\" : \"\" ) .href( \"#completed\" ), \"Completed\" ) ) ), AppData.model.completedCount() &gt; 0 ? button( new BtnProps().className( \"clear-completed\" ).onClick( _handleClearCompleted( this ) ), \"Clear Completed\" ) : null ); } } Optimizing the component However this is not the most efficient component. There are several scenarios where the component wil re-render but produce identical output. This is inefficient as React4j will take time to re-render the component to the virtual DOM and then additional time to reconcile the virtual DOM against the actual DOM. Whether this inefficiency has any impact on the user experience will depend upon the application. In particular it will depend on how frequently the observable data changes, what other parts of the view are updated when the same observable data changes and how dynamic and complex the remainder of the view is. It is often the case that re-rendering the entire component is perfectly fine and will have no impact on the users experience, as in the case with a TodoMVC implementation. However let’s assume that this component needs to be optimized and walk through the steps that would be required to optimize the component to reduce the scope and frequency of re-renders. Use @Computed If you turn on “Highlight Updates” in React’s DevTools you will notice that the whole component re-renders any time a Todo is toggled from “complete” to “not complete” or vice-versa. However the html output only changes if the number of completed Todos changes from 0 to not zero or from not zero to zero. To eliminate these unnecessary renders, the simplest approach is to extract the expression AppData.model.completedCount() &gt; 0 into a separate @Computed method. The render() method will only be scheduled to render if the value returned from the @Computed method changes. This method will look like: @Computed boolean hasCompletedItems() { return AppData.model.completedCount() &gt; 0; } Using computed properties is one of the easiest and least intrusive mechanisms for optimizing components. Extract Components If we return to React’s DevTools and turn “Highlight Updates” on again. The next thing you will notice is that the component is re-rendered any time a Todo is added or removed as the value for the expression AppData.model.totalCount() changes. Unfortunately @Computed will not help us here as the html output changes every time a re-render occurs. However we can decide to limit the scope of the rendering by extracting a component that encapsulates the html that changes. @ReactComponent class FooterTodoCount extends ReactArezComponent&lt;BaseProps, BaseContext&gt; { @Nonnull static ReactNode create() { return _create(); } @Nullable @Override protected ReactNode render() { final int count = AppData.model.totalCount(); final String activeTodoWord = \"item\" + ( count == 1 ? \"\" : \"s\" ); return span( new HtmlProps().className( \"todo-count\" ), strong( Integer.toString( count ) ), text( \" \" + activeTodoWord + \" left\" ) ); } } This component can be rendered via an expression such as React.createElement( FooterTodoCount_.TYPE ). The FooterTodoCount component will still be re-rendered every time a Todo is added or removed but the scope of the re-render is much smaller and thus the amount of work that React4j has to do is much smaller. We could also extract another component to manage the links and only re-render this new component when the filterMode observable property changes but we have decided against this as it is a relatively infrequent event. The final Footer component looks something like: @ReactComponent class Footer extends ReactArezComponent&lt;BaseProps, BaseContext&gt; { @EventHandler( MouseEventHandler.class ) void handleClearCompleted() { AppData.service.clearCompleted(); } @Nullable @Override protected ReactNode render() { final FilterMode filterMode = AppData.viewService.getFilterMode(); return footer( new HtmlProps().className( \"footer\" ), FooterTodoCount.create(), ul( new HtmlProps().className( \"filters\" ), li( a( new AnchorProps() .className( FilterMode.ALL == filterMode ? \"selected\" : \"\" ) .href( \"#\" ), \"All\" ) ), li( a( new AnchorProps() .className( FilterMode.ACTIVE == filterMode ? \"selected\" : \"\" ) .href( \"#active\" ), \"Active\" ) ), li( a( new AnchorProps() .className( FilterMode.COMPLETED == filterMode ? \"selected\" : \"\" ) .href( \"#completed\" ), \"Completed\" ) ) ), hasCompletedItems() ? button( new BtnProps().className( \"clear-completed\" ).onClick( _handleClearCompleted( this ) ), \"Clear Completed\" ) : null ); } @Computed boolean hasCompletedItems() { return AppData.model.completedCount() &gt; 0; } } On Optimizing Ultimately measuring performance and optimizing when needed to keep within your performance budget is the ideal goal. It is important to know which parts of your application need to be fast and which parts are less important to optimize. In some cases, the application is small enough to never need optimization while in others optimizing components by default may be a good option (i.e. if the cost of optimization is lower than the cost of determining which parts of the application to optimize). Best Practices Arez and React4j is such a powerful combination that many of the best practices that you use when building a React4j application no longer make sense after you integrate Arez. However this section will try to give some helpful suggestions that simplify your development experience. You should also checkout the Arez FAQ Section. UI state should be modelled with Arez Observable State Often applications start by just modelling the application domain classes as observable state. So an application has observable entities to model Employee, Sale, Customer etc. However it is extremely useful to model user interface state such as which tab is visible, the current application place or route, whether a button is visible etc. using observable state. This provides a single, unified mechanism for reacting to changes and updating the user interface. In an ideal world, we should be able to persist the arez observable state, relaunch the web page and load the observable state and the application should appear just as it was before the relaunch. The question often arises, when should you use React4j component level state. In most cases this state is no longer necessary however it sometimes makes sense to use it if: The component would otherwise be a generic component and need not extend ReactArezComponent. The state never needs to be shared with any other component. Avoid writing “business logic” in your React4j components In an ideal world your Arez React4j application, React4j should just be providing the view and Arez should provide the business logic. The business logic method in the Arez components are then called from React4j components. This makes it much easier to reuse, refactor and test the business logic. In most cases the business logic can be tested outside the browser in pure java. Another advantage is that it makes the application much easier to understand. Separate network interactions from React4j components and other arez business logic components Network interactions can be notoriously difficult to test. They are business logic and should not be put in your React4j components and instead should be triggered from arez components. One approach is to extract the service API calls behind an interface and pass the service interface into the constructor of the arez component. This way the unit tests can pass in a mock API service during testing. Consider the example where you have an action that wants to transition to a view listing employees and wants to load all the employee data for the view. A typical example using the “extract a remote service interface” strategy would be: @ArezComponent public class EmployeeService { private final RemoteServiceAPI _remote; private boolean _loading; private String _employeeData; private String _errorMessage; public EmployeeService( final RemoteServiceAPI remote ) { _remote = remote; } @Action public void changeToEmployeeView() { setLoading( true ); _remote.loadEmployeeData( data -&gt; { setLoading( false ); setEmployeeData( data ); }, errorMessage -&gt; { setLoading( false ); setErrorMessage( errorMessage ); } ); } @Observable public boolean isLoading() { return _loading; } public void setLoading( final boolean loading ) { _loading = loading; } @Observable public String getEmployeeData() { return _employeeData; } public void setEmployeeData( final String employeeData ) { _employeeData = employeeData; } @Observable public String getErrorMessage() { return _errorMessage; } public void setErrorMessage( final String errorMessage ) { _errorMessage = errorMessage; } } Another approach that is even easier to test and arguably easier to understand is to have the the @Action annotated method set state the defines the “intent” to perform a remote service and then have a separate arez component that uses an @Autorun method that observes the “intent” and performs remote call when the intent indicates that it is required. So this results in some minor modifications to the employee service so that the action is implemented as follows: private boolean _loadEmployeeData; @Observable( name = \"loadEmployeeData\" ) public boolean shouldLoadEmployeeData() { return _loadEmployeeData; } public void setLoadEmployeeData( final boolean loadEmployeeData ) { _loadEmployeeData = loadEmployeeData; } @Action public void changeToEmployeeView() { setLoadEmployeeData( true ); } Then there would be a separate arez component to observe the intent and perform the remote call: @ArezComponent public class EmployeeDataLoader { private final RemoteServiceAPI _remote; private final EmployeeService _service; public EmployeeDataLoader( final RemoteServiceAPI remote, final EmployeeService service ) { _remote = remote; _service = service; } @Autorun public void loadEmployeeDataIfRequired() { if ( _service.shouldLoadEmployeeData() ) { _service.setLoading( true ); _remote.loadEmployeeData( data -&gt; { _service.setLoading( false ); _service.setEmployeeData( data ); _service.setLoadEmployeeData( false ); }, errorMessage -&gt; { _service.setLoading( false ); _service.setErrorMessage( errorMessage ); _service.setLoadEmployeeData( false ); } ); } } } This approach where you separate intent and have another component that performs the remote call means that your unit tests are much more focused and simpler to understand. It has the disadvantage that it requires more verbose code constructs and can result in more abstraction and indirection. In a small application with a single developer this can have a negative effect. Larger applications with larger teams may benefit from the higher level of abstraction. Avoid arez annotations other than @Computed and @Action in React4j components Following the above best practices, you will find you rarely if ever need to annotate any methods in a ReactArezComponent subclass with any Arez annotations other than @Computed and @Action and as most uses of @Action are in @EventHandler annotated methods that default to being annotated with an @Action you may find that is rarely a good use case for using @Action in your react components."
					}

					
				
			
		
			
				
					,
					

					"compared-to-react": {
						"id": "compared-to-react",
						"title": "Compared to React",
						"category": "",
						"url": " /compared_to_react/",
						"content": "React4j is based on React so it is natural to ask how they compare and what are the differences between the two libraries. React4j is written in Java rather than javascript so there are some features thar just don’t make sense to implement in a Java environment. There are also some features of React that exist for legacy reasons so are not implemented in React4j. The constructor versus componentDidConstruct In React, components perform initialization in their constructor except for “Stateless Function Components” (SFCs) which do not need initialization as they are stateless. However, we found that in many react applications there are a lot of SFCs or stateful components that perform no initialization or only perform event handler binding (which is not used in React4j). As such we found it to be unnecessary boilerplate and complexity. In React4j, we decided that components need not define a constructor and could instead make use of the default constructor automatically provided by the runtime. If you wanted to perform per-component initialization you can override the lifecycle method componentDidConstruct. In practice we found it was rarely used. setState versus scheduleStateUpdate In React, setState(...) enqueues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state. This can be confusing to new users who sometimes try to read the state property immediately after calling setState(...) and the “old” value is returned. To avoid this confusion React4j decided to rename this method to scheduleStateUpdate(). This continues to be the primary method you use to update the user interface in response to event handlers and server responses. forceUpdate versus scheduleRender In React, forceUpdate(...) tells the runtime to schedule the component for re-rendering. If this method is invoked it will skip the shouldComponentUpdate() method. It is not an uncommon pattern for a component to schedule a re-render by invoking setState({}) if you still want the component to call shouldComponentUpdate() lifecycle method. To unify these two mechanisms for scheduling a render, React4j decided to define the method to scheduleRender(boolean force). If you pass force = true then forceUpdate() will be invoked on the underlying react component otherwise setState({}) will be invoked. In both React and React4j, explicitly scheduling a re-render should be avoided but if you need to do it you can. getInitialProps versus defaultProps In React, a static property named defaultProps on the class or constructor tells the react runtime the default props for a component. The props provided by the developer are merged into these props. The equivalent in React4j is the getInitialProps() static method on the component class. This method is called when the component constructor function is created and the results are set as the default props for the component. The method must be static, non-private, have no parameters, throw no exceptions and must return a value that is compatible with the prop type for the component. JSX Most react code uses JSX to build component hierarchies. JSX is an xml-like syntax extension that is processed by a transpilers to transform the xml-like expression tokens into standard ECMAScript. Consider the following JSX to render a drop-down list: &lt;Dropdown&gt; A dropdown list &lt;Menu&gt; &lt;MenuItem&gt;Do Something&lt; MenuItem&gt; &lt;MenuItem&gt;Do Something Fun!&lt; MenuItem&gt; &lt;MenuItem&gt;Do Something Else&lt; MenuItem&gt; &lt; Menu&gt; &lt; Dropdown&gt; This would be transpiled into: React.createElement(Dropdown, null, \"A dropdown list\", React.createElement(Menu, null, React.createElement(MenuItem, null, \"Do Something\"), React.createElement(MenuItem, null, \"Do Something Fun!\"), React.createElement(MenuItem, null, \"Do Something Else\") ) ) React also supports html inside JSX which would transform: &lt;section&gt; &lt;h1&gt;My Title&lt; h1&gt; &lt;p&gt;My text...&lt; p&gt; &lt; section&gt; into React.createElement(\"section\", null, React.createElement(\"h1\", null, \"My Title\"), React.createElement(\"p\", null, \"My text...\") ); React4j does not have the option to use a transpiler so has to use the createElement approach directly. An introduction to this approach can be found in the article “Learn Raw React — no JSX, no Flux, no ES6, no Webpack…”. And the java code is very similar to the transpiled output. However this approach can be too verbose, so most code actually uses a factory based approach such as the code that follows. In some cases this is more verbose than the equivalent JSX and sometimes it is more succinct. section( h1( \"My Title\" ), p( \"My text...\" ) ); Stateless Function Components Stateless function components or SFCs are often used in React but not so much in React4j. The reasoning for this is in the answer to the FAQ question “Where is the equivalent of React’s stateless function components?”"
					}

					
				
			
		
			
				
					,
					

					"dependency-injection": {
						"id": "dependency-injection",
						"title": "Dependency Injection",
						"category": "",
						"url": " /dependency_injection/",
						"content": "React4j can be integrated with dependency injection frameworks such as Dagger2 and GIN. The dependency injection framework is responsible for creating the component and injecting the required dependencies. The author declares the dependencies of a React4j component by annotating fields or setter methods with the @Inject annotation. The annotation processor then detects these dependencies and generates the required infrastructure for injecting dependencies into the react4j component. The author can explicitly control the injection infrastructure generated by setting the inject parameter on the @ReactComponent annotation. The @ReactComponent annotation on the component can explicitly enable injection (by setting the value of the inject parameter to TRUE), explicitly disable injection (by setting the value of the inject parameter to FALSE) or leave value as IF_DETECTED to automatically determine whether the injection infrastructure is required. Enabling injection for a component will mean that the component will be constructed by an instance of javax.inject.Provider that is expected to be provided by the injection framework. The enhanced component subclass will have a static field for the javax.inject.Provider instance that must be configured prior to instantiating the component. Enabling injection will also result in the addition of an @javax.inject.Inject annotation being added to the constructor of the enhanced component subclass. Components that extend ReactArezComponent have slightly different mechanisms for implementing this functionality and tie into the [dependency injection])(https: arez.github.io components dependency_injection) infrastructure provided by Arez. However there should be no practical differences from the perspective of a React4j user. Dagger2 Dagger2 is a modern take on a dependency injection framework that uses annotation processors and statically checks the object graph at compilation time. The root objects in the graph are accessed via a component which is an interface annotated by the @dagger.Component annotation. The injection rules are customized via @dagger.Module annotated classes. React4j has greater support for the dagger injection framework than GIN. The @ReactComponent annotation has a dagger parameter that controls whether the React4j annotation processor generates a dagger subcomponent and supporting module. As with the inject parameter it can be explicitly enabled, disabled or the default value IF_DETECTED. The IF_DETECTED value determines whether the component requires injection and whether dagger is present on the classpath and enables dagger if these conditions are true. If dagger is enabled then the react4j annotation processor generates an additional class named [ComponentName]DaggerFactory that aims to simplify integration into dagger based infrastructure. The infrastructure looks like: public interface MyComponentDaggerFactory { DaggerSubcomponent getMyComponentDaggerSubcomponent(); default void bindMyComponent() { MyComponent_.setProvider( () -&gt; getMyComponentDaggerSubcomponent().get() ); } @Module final class DaggerModule { @Provides static Component provideComponent( final MyComponent_ component ) { return component; } } @Subcomponent( modules = DaggerModule.class ) interface DaggerSubcomponent { Provider&lt;Component&gt; createProvider(); default MyComponent get() { return (MyComponent) createProvider().get(); } } } Integration into a dagger component is as simple as extending the [ComponentName]DaggerFactory. This results in a dagger component like: @Singleton @Component( modules = { SomeDaggerModule.class } ) public interface ExampleDaggerComponent extends MyComponentDaggerFactory { } The following code example shows how to instantiate the Dagger component and bind the Provider instance to the enhanced component class. Unfortunately it is currently required that the developer invokes the bind[ComponentName]() method for every component is injection enabled. In the future this may not be required but it is at this stage. final ExampleDaggerComponent component = DaggerExampleDaggerComponent.create(); component.bindMyComponent();"
					}

					
				
			
		
			
				
					,
					

					"faq": {
						"id": "faq",
						"title": "Frequently Asked Questions",
						"category": "",
						"url": " /faq/",
						"content": "Design Will React4j work on future versions of GWT? React4j was designed from the ground up to be as forward compatible as possible with future versions of GWT. Google is currently working on J2CL (Java 2 Closure Compiler) which is a modern take on a java-to-javascript transpiler that emits Closure Compiler annotated javascript as output. This promises a modern take on the story with an even more advanced optimizing compiler working in the background. React4j aims to target J2CL as early as possible while maintaining compatibility with GWT2.x for as long as possible and likely targeting GWT 3.x into the future. The library does this by using jsinterop and elemental2 to interact with the browser. Where is the equivalent of React’s stateless function components? The project originally supported stateless functional components defined by an interface that had a single render method. You could define the rendering of the method using a simple lambda method that accepted a props object. This resulted in code that looked like: class MyComponent { @JsType(isNative = true, namespace = JsPackage.GLOBAL, name = \"Object\") static class Props extends BaseProps { int param; } @ReactComponent public static final StatelessComponent&lt;Props&gt; COMPONENT = (props) -&gt; { return span(new HtmlProps().className(\"myclass\"), String.valueOf( props.param )); }; } Contrast this with code that uses normal components: @ReactComponent class MyComponent extends Component&lt;MyComponent.Props, BaseState&gt; { @JsType(isNative = true, namespace = JsPackage.GLOBAL, name = \"Object\") static class Props extends BaseProps { int param; } public ReactElement&lt;?, ?&gt; render() { return span(new HtmlProps().className(\"myclass\"), String.valueOf( props.param )); }; } In java, the StatelessComponent approach seemed to offer few advantages. The two approaches were roughly equal in the amount of ceremony required and identical from a performance standpoint. However the StatelessComponent approach required more work if you needed to refactor the components later to add state, or use the lifecycle callback methods. So we removed StatelessComponent and simplified our application, the library and supporting tools. (The annotation processor is significantly simpler as a result of this change.) The react team has promised that at some point in the future, stateless functional components will have a better performance profile due to lower memory usage and low-level optimization opportunities within the react runtime. When this eventuates, it will be reasonably easy for React4j to take advantage of these enhancements with no changes to the way components are written. The annotation processor already analyzes the component to determine if the component uses state or if any lifecycle methods are declared. If neither of these conditions is true, React4j could transparently expose the component as a stateless functional component and take advantage of the potential performance enhancements. Actually it turns out that functional components should be slightly faster in React 16 as there’s no instance created to wrap them unlike in React 15. However this seems to be obscured by the slight overhead of React4j but when if the performance becomes more discernible, expect React4j to begin supporting stateless functional components. It should be noted that a month or two after we had made this decision the article “7 Reasons to Outlaw React’s Functional Components” was published and a similar sentiment arose in the Javascript community. Why is there both NativeComponent and Component classes? The project initially required that React4j components all extend the equivalent of the NativeComponent and thus React4j components had to be exported as javascript objects using the @JsType(isNative = false) annotation. This model required that the developer was very aware of the constraints of developing classes that would be exported as javascript. This often resulted in lots of code being annotated with either @JsIgnore or @SuppressWarnings(\"unusable-by-js\") to avoid warnings being generated by the GWT compiler. The developer experience was less than optimal. Building a parallel component hierarchy allowed us to remove the boilerplate and constraints required to export a native object to javascript. It also made it possible to add additional validation to verify that the application code interacts with the native react runtime correctly. Why does React4j manually export types to Javascript? GWT has @JsType(isNative = false) and yet the framework does not use it. The main reason is that this is not a use case that the J2CL GWT compiler team want to support. @JsType(isNative = false) is intended to be used to export classes for consumption by other javascript projects and requires that the consumers of the library pass command line arguments to the compiler to control which parts of the framework is exported to native javascript. React4j needs to export components in a particular shape so that the native javascript library knows how to use the components. Turning off exports or excluding the wrong elements would result in a broken library. As the J2CL GWT team have taken a philosophical stance against controlling the export of code inside .gwt.xml, there is a strong possibility that users of React4j could end up with broken applications through incorrect build configuration. To avoid this scenario impacting users of React4j, the library manually exports the components to native code. Users of the library are free to use @JsType(isNative = false) and control it through the normal means but this should not impact the correctness of the React4j &lt;=&gt; react integration. The amount of code that is manually exported to Javascript has been minimized and is mostly restricted to the equivalent of static class properties in ES6 and a constructor function. Arez Integration Which components should extend ReactArezComponent? Any component that uses arez observable properties or computed properties within the render() method should extend ReactArezComponent. This ensures that the component is scheduled for re-render when the data changes. Sometimes you want to share a generic component between projects and rather than passing arez reactive components into the component and making the generic component extend ReactArezComponent you can instead pass in simple values as props into the generic component. The container component will still extend ReactArezComponent and will be re-rendered when the observable and or computed properties change and will pass new props to the generic component forcing it to re-render. This is slightly less optimized but allows you to create generic components like ToggleButton rather than domain specific TodoToggleAllButton. Should components implement custom shouldComponentUpdate() method? The ReactArezComponent class already implements an optimized shouldComponentUpdate() that will only trigger a re-render if the dependent observable computed properties have changed, the state has changed or a shallow comparison of props produces no differences. In most scenarios, it is not necessary to override shouldComponentUpdate() but if you need to override the method shouldComponentUpdate() then it is possible however you should return true if ReactArezComponent.hasRenderDepsChanged() returns true to ensure integration works as expected. Why is there an ‘arez’ key in component state? Components that extend ReactArezComponent will automatically have a key arez set if the configuration property react4j.arez.store_arez_data_as_state is set to true. This can be done manually or by inheriting from the GWT module react4j.arez.ReactArezDev. The purpose of this is to give the developer a quick visual indication of the direct arez dependencies of the ReactArezComponent. It began as a stop-gap measure until a “Arez DevTools” tool was implemented but remained as people found it useful. This should NOT be enabled in production code as updating the dependency information can cause a re-render of the component even though there is no actual changes to the content rendered in the browser. Why can’t render methods update observable state? Arez has the concept of read-write and read-only transactions and observable state should only be modified in read-write transactions. This is enforced in development mode and assertion failures will occur if you attempt to modify observable state in a read-only transaction. The render() method is deliberately wrapped in a read-only transaction. The main reason for this is to disallow a render triggering further renders and to stop potentially long render times as other observers react to changes in observable state. The underlying react library also considers this pattern a very bad idea conceptually and performance-wise and likewise blocks calling setState() from within the render method."
					}

					
				
			
		
	};
</script>
<script src="/scripts/lunr.min.js"></script>
<script src="/scripts/search.js"></script>

			</article>
		</section>

		<script>
			document.getElementById("open-nav").addEventListener("click", function () {
				document.body.classList.toggle("nav-open");
			});
		</script>
	</body>
</html>
